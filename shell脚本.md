## 　**脚本的基本概念**
> ### **编程逻辑处理方式**  
1. 顺序执行  
2. 循环执行 
3. 选择执行  
> ### **shell脚本的基本结构**
1. 首行要shebang机制（#！用到的语言）  
```bash
#!/bin/bash  
#Filename:        www.sh  
#Date:            2017-1-11  
#Description:     this is the first script  
```
>检测脚本中的语法错误
- bash -n /path/some_script (只能检测语法错误，不能检测命令错误)
> 调试执行
- bash -x /path/some_script (可以详细列出执行过程，和每一步的结果输出)
>如何运行脚本
1. 写完脚本要用bash -n 检测一下是否有语法错误  
2. 因为我们用文本文档写的脚本默认是没有执行权限的所以要用chmod为脚本添加执行权限  
3. 运行脚本，可以用bash 加绝对路径可以运行， 也可以把脚本加入PATH路径中这样直接输入脚本名，或者在脚本文件中直接运行。  
## **变量**
- 变量：命名的内存空间
- 变量的作用
  - 数据存储格式
  - 参与运算
  - 表示的数据范围

+ 强类型
  - 变量不经过强制转换，它永远是这个数据类型，不允许隐式的类型转换。一般定义变量时必须指定类型、参与运算必须符合类型要求；调用未声明变量会产生错误
+ 弱类型
  - 语言的运行时会隐式做数据类型转换。无须指定类型，默认均为字符型；参与运算会自动进行隐式类型转换；变量无须事先定义可直接调用

+ 变量的命名法则
  1. 不能使用程序保留的字:列如if,for
  2. 只能使用数字下划线和字母，第一位不能以数字开头
  3. 名字最好起的能看见名字大概知道什么

> 变量声明
- 如何设置变量
```bash
[root@centos7 ~]# haha=25
[root@centos7 ~]# echo $haha
25
[root@centos7 ~]# haha=25
[root@centos7 ~]# echo $haha
25
[root@centos7 ~]# i=$haha 我们调用haha的值为i赋值
[root@centos7 ~]# echo $i 现在i也是25
25
[root@centos7 ~]# haha=1  在把haha值赋值到1
[root@centos7 ~]# echo $haha,$i 现在看到i的值并没有跟着haha的值而改变，而i的值还是25，所以在以后中不用的变量要用命令删除
1,25
```
- 从上面可以清楚看到重新赋值并不是覆盖原来的值，而是从新定义一段内存空间存储这个值。原来的值并不能马上消失。
>删除变量命令  :unset name

> bash 的种类
- 根据变量的生效范围等标准划分下面的变量类型  
   + 局部变量：生效范围为当前shell进程；对当前之外的其它shell进程，包括当前shell的子进程和父进程均无效。
   + 环境变量（全局）：生效范围为当前shell进程及其子进程
   + 本地变量：生效范围为当前shell进程中某代码片段，通常指函数
   + 位置变量：$1，$@,...l来表示，用于让脚本在脚本代码中调用通过命令行传递给它的参数
   + 特殊变量：$?,$0,$*,$@,$#,$$

> 局部变量声明
- 变量赋值 ：name='Value'
- 可以使用引用value :
  1. 可以直接是字串；name="root"
  2. 可以直接引用已有的变量：name="$USER"
  3. 命令引用：name=`command` name=$(command)
- 变量引用：${name}  $name
  - "" : 弱引用，其中的变量引用会被替换为变量值  
  - '' : 强引用，其中的变量引用不会被替换，保持原字符串
  - 显示已定义的所有变量：set
  - 删除变量 ： unset name
#### <font color=red>重要</font>
+ () 的用法  
  1. 我们学过如果把多条命令的输出结果重定向文件中可以用（）这样可以把多条命令结果输出到一个文件中。
  ```bash 
  [root@centos7 app]# (ls /app /root/) > 12.txt
  ```
  2. 但是我们可以临时对变量声明或者对命令，执行结束后将不会对现有的环境产生影响。
  ```bash  
  [root@centos7 app]# (cd /etc/ ;pwd)  
  /etc   这里已经执行完cd命令结束后我们还在原来路径。但是pwd命令显示是已经执行成功并且显示绝对路径。  [root@centos7 app]#   
  ```
  3. 从上面可以看出在（）里的命令相当于在当前bash进程中开了一个子进程把命令执行完后返回当前进制。那我们也可以定义临时只用一次的变量用完后释放掉这样避免一些错误，和增加系统负担。
> 变量声明(环境变量)
  + export name=VALUE
  + declare -x name=VALUE
> 显示所有环境变量
- env
- printenv
- export
- declare -x
> 只读变量：只能声明，但不能修改和删除。
- 声明只读变量：
    + readonly name
    + cdclare -r name
- 查看只读变量
    + readonly -p
    + cdclare -r
> 位置变量：在脚本代码中调用通过命令行传递给脚本参数
1. $1,$2,...：对应的1、第2、等参数值，
2. $0 :命令本身
3. $* :传递给脚本所有参数，全部参数合为一个字符串
4. $@ :传递给脚本的所有参数，每个参数为独立字符串
5. $# :传递给脚本的参数的个数  
6. $@、$* 只在被双引号包起来的时候才会有差异
7. set -- 清空所有位置变量

>  退出状态
  >> 进程使用退出状态来报告成功或者失败  
  >> 0 代表成功，1-255代表失败  
  >> $？变量保存最近的命令退出状态  
  >> 示范: echo $?    

> 退出状态码  
  >> bash可以自定义退出状态码
  >> exit[n] :自定义退出状态码
  >> 注意：脚本中一旦遇到exit 命令，脚本会立即终止；终止退出状况取决于exit命令后的数字
  >> 注意：如果未给脚本指定退出状态码，整个脚本的退出状态码取决于脚本执行的最后一条命令的状态码

### bash内建的环境变量
- PATH ：命令查询的路径环境变量
- SHELL : 当前所用的shell
- USER : 当前用户
- UID : 0
- HOME :当前用户的家目录
- PWD :当前绝对路径
- SHLVL :当前bash进程嵌套
- LANG :语言
- MAIL :邮箱存放目录
- HOSTNAME :主机名
- HISTSIZE :命令历史最大存放多少条
- _ ：最后一条命令的参数
### <font color=red>算术运算</font>  
> bash中的算术运算
 >> \+ ,- ,*,/,%取模（取余），**乘方  

- 实现算术运算  
```bash
[root@centos7 app]# i=10
[root@centos7 app]# m=20
[root@centos7 app]# echo $i $m
10 20 
```
- 从上面声明i=10,m=30
1. let var(新的变量名)=算术表达式
```bash
[root@centos7 app]# let n=1+2
[root@centos7 app]# echo $n
3
```
2. var=$[算术表达式]
```bash
[root@centos7 app]# c=$[i+n];echo $c
13
[root@centos7 app]# d=$[1+5];echo $d
6
```
3. var=$((算术表达式))
```bash
[root@centos7 app]# q=$((c+i)) ;echo $q   
23
```
4. var=$(expr arg1 arg2 arg3 ...)注意expr是一个运算命令，参数之家都要有空格
```bash 
[root@centos7 app]# gg=$(expr 2 + 3)
[root@centos7 app]# echo $gg
5
[root@centos7 app]# expr 2 + 5
7
```
5. declare –i var = 数值  这是定义为数值变量
6. echo ‘算术表达式’ | bc

- 乘法符号有些场景中需要转义。
-  bash有内建的随机数生成器：$RANDOM（0-32767）echo $[$RANDOM%50] ：0-49之间随机数
### 赋值 
+ 增强型赋值
- += ，-= ，*= ，/= ， %=
- 示列
```bash
[root@centos7 app]# let yy+=3 ;echo $yy
12
[root@centos7 app]# let yy+=3 ;echo $yy
15
[root@centos7 app]# 0
```
- 自增、自减
  + let var+=1  =  let var++
  + let var-=1  =  let var--
  + <font color=red>let var++  echo$?返回的值是错误值
  + let ++var  echo$?返回的值是正确的</font>
### <font color=red>逻辑运算</font>
- true =1  false =0
> 与:   都是真时才是真，不然是假
  >>1 与 1 = 1  
  >>1 与 0 = 0  
  >>0 与 1 = 0  
  >>0 与 0 = 0  

> 或 ：有一个是真就是真，条件全为假时为假
  >>1 或 1 = 1  
  >>1 或 0 = 1  
  >>0 或 1 = 1  
  >>0 或 0 = 0  

> 非 ：！ 取反
  >>!1 = 0
  >>!0 = 1

> 短路运算
+ 短路与
   + 第一个为0，结果必定为0，不会在继续执行第二个命令
   + 第一个为真或1，则第二个要参与运算
   + && 这符号表示短路与
+ 短路或
   + 第一个为1，结果必定为一，第二个则不参加运算  
   + 第一个为0，第二个要参加运算。  
   + || 这个符号表示短路或
+ 异或
   + 异或的两个值，相同为假，不同为真
   + ^ 这个符号表示异或

- exor 命令运算结果为0是 echo$? 返回结果为1显示为错误的值。
- let m=0 ；echo$? 
- let 运算值为0时也会返回错误值


> test 命令是shell环境中测试条件表达式的实用工具。[] 中括号是test的简写
- <font color=red>[] 中括号里的变量要用引号引起 </font>
- [[]] 只支持扩展正则表达式，正则表达式不能加引号

> 选项  
  - v 变量是否设置
>  数值测试
  - -gt  是否大于
  - -ge  是否大于等于
  - -eq  是否等于
  - -ne  是否不等于
  - -lt  是否小于
  - -le  是否小于等于
>　字符串测试
  - ==   是否等于
  - \>   ascii码是否大于ascii
  - \<   是否小于
  - !=   是否不等于
  - =~   左侧字符是否能被右侧的PATTER 所匹配
- 注意: 此表达式一般用于[[ ]]中；扩展的正则表达式
- -z "STRING“ 字符串是否为空，空为真，不空为假
- -n "STRING“ 字符串是否不空，不空为真，空为假
- 注意：用于字符串比较时的用到的操作数都应该使用引号